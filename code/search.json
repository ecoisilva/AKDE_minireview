[
  {
    "objectID": "AKDE_R-tutorial.html",
    "href": "AKDE_R-tutorial.html",
    "title": "Guide to autocorrelated home range estimation",
    "section": "",
    "text": "This tutorial is a companion piece to our manuscript “Autocorrelation-informed home range estimation: a review and practical guide”. Manuscript was published in Methods in Ecology and Evolution. Preprint is also available on EcoEvoRxiv. For any definitions, check the main manuscript or the Glossary. Download this tutorial as a .pdf file here.\nTo cite this material:"
  },
  {
    "objectID": "AKDE_R-tutorial.html#step-1.-formatting-and-loading-an-animal-tracking-dataset",
    "href": "AKDE_R-tutorial.html#step-1.-formatting-and-loading-an-animal-tracking-dataset",
    "title": "Guide to autocorrelated home range estimation",
    "section": "Step 1. – Formatting and loading an animal tracking dataset",
    "text": "Step 1. – Formatting and loading an animal tracking dataset\nYou can import data into R through the read.table() or read.csv() functions; make sure to navigate to the appropriate folder or working directory. You can find two example files within the GitHub repository data folder. To read these .csv files into R:\n\ninstall.packages(\"here\")\nlibrary(here)\n\nhere() # your working directory\n\n# First, list all files in a specific folder:\nlist.files(\"data\") # verify that your file appears here\n\n\n# Then load the file:\nanimal0_longlat <- read.csv(here(\"data/example_data_longlat.csv\"))\nhead(animal0_longlat)\n\n       ID        timestamp longitude latitude\n1 animal0 2005-07-14 05:35  30.59648 65.24774\n2 animal0 2005-07-14 07:35  30.53256 65.27085\n3 animal0 2005-07-14 08:34  30.52398 65.26446\n4 animal0 2005-07-14 09:35  30.52848 65.25948\n5 animal0 2005-07-14 10:35  30.53382 65.26643\n6 animal0 2005-07-14 11:34  30.49970 65.27868\n\n# or:\nanimal0_utm <- read.csv(here(\"data/example_data_utm.csv\"))\nhead(animal0_utm)\n\n       ID        timestamp UTM.Easting UTM.Northing  UTM.zone\n1 animal0 14/07/2005 05:35    387730.0      7238204 36 +north\n2 animal0 14/07/2005 07:35    384846.3      7240894 36 +north\n3 animal0 14/07/2005 08:34    384418.1      7240197 36 +north\n4 animal0 14/07/2005 09:35    384606.5      7239634 36 +north\n5 animal0 14/07/2005 10:35    384885.8      7240399 36 +north\n6 animal0 14/07/2005 11:34    383347.9      7241826 36 +north\n\n\n\n# Finally, convert to telemetry object:\nanimal0a <- as.telemetry(animal0_longlat)\nanimal0b <- as.telemetry(animal0_utm)\n# if left unspecified, as.telemetry() will assume timezone = UTC, datum = WGS84\n\nBoth these files represent the same individual, with either longitude/latitude, or UTM coordinates (easting, northing, and zone), and both outputs —animal0a and animal0b— will show the same coordinates after conversion. In general, the as.telemetry() function will immediately identify the columns if they are correctly named, convert the projection if needed, and then output the minimum sampling interval for each individual in the dataset. In this example, animal0 has a minimum sampling interval of 59 minutes.\n\n1.1. Buffalo tracking data\nFor this tutorial, we will use data already prepared into a list of telemetry objects. We can load it directly from the ctmm R package with the data() function:\n\ndata(\"buffalo\")\nanimal1_buffalo <- buffalo[[4]] # selecting individual number 4\nhead(animal1_buffalo)\n\n                timestamp longitude  latitude          t         x         y\n17517 2006-04-25 05:09:00  31.73749 -24.19705 1145941740 -51803.35 -2715.663\n17518 2006-04-25 06:09:00  31.73653 -24.19929 1145945340 -51569.29 -2845.660\n17519 2006-04-25 07:09:00  31.73946 -24.20100 1145948940 -51340.72 -2576.353\n17520 2006-04-25 08:09:00  31.73987 -24.20092 1145952540 -51344.11 -2533.788\n17521 2006-04-25 10:09:00  31.74086 -24.20365 1145959740 -51029.45 -2474.771\n17522 2006-04-25 11:09:00  31.74098 -24.20370 1145963340 -51022.23 -2463.655\n\n# Plotting locations:\nplot(animal1_buffalo)\n\n\n\n\nThis dataset showcases an irregular sampling schedule: the buffalo nicknamed “Pepper” had a sampling rate shift from one fix every hour to one fix every two hours. We will use this dataset to highlight data irregularity and the wAKDE mitigation measure.\n\n\n1.2. Gazelle tracking data\n\ndata(\"gazelle\")\nanimal2_gazelle <- gazelle[[11]] # selecting individual number 11\nhead(animal2_gazelle)\n\n             x          y       t\n2742  18152.70  -8539.799       0\n2743  15931.16 -32069.788 1306800\n2744  17678.84 -28632.329 1396800\n2745  23135.50 -23820.789 1486800\n2746 -20310.78  20348.792 2419200\n2747 -17920.31  20598.668 2509200\n\n# Plotting locations:\nplot(animal2_gazelle)\n\n\n\n\n\nHome range crossing time: the time required for an animal to cross the linear extent of its home range.\n\nMongolian gazelles have a home range crossing time of a few months, and with a maximum longevity around 10 years, it is impossible to get a considerable effective sample size no matter the study duration (Fleming et al., 2019). We will use this dataset to highlight how to check effective sample size and apply the parametric bootstrap mitigation.\n\nEffective sample size (N): number of range crossings that occurred during the observation period. Can be roughly estimated by dividing the duration of the tracking dataset by the average home range crossing time parameter."
  },
  {
    "objectID": "AKDE_R-tutorial.html#step-2.-checking-for-the-range-residency-assumption",
    "href": "AKDE_R-tutorial.html#step-2.-checking-for-the-range-residency-assumption",
    "title": "Guide to autocorrelated home range estimation",
    "section": "Step 2. – Checking for the range residency assumption",
    "text": "Step 2. – Checking for the range residency assumption\nFirst, we want to check if our first tracking dataset (animal1_buffalo) can be used for home range estimation by checking for range residency. To achieve this, we calculate the semi-variance function (SVF), and visualize it through the variogram() function.\n\nRange residency: the tendency of an animal to remain within their home range.\n\nVariograms are an unbiased way to visualize autocorrelation structure, representing the average square displacement (y-axis) over a specific time lag (x-axis). To facilitate interpretation, we have the SVF of animal1_buffalo zoomed out (right) to showcase all time lags and (left) zoomed in to showcase time lags up to two months:\n\nlevel <- 0.95 # we want to display 95% confidence intervals\nxlim <- c(0,2 %#% \"month\") # to create a window of 2 months\n\nSVF <- variogram(animal1_buffalo)\npar(mfrow = c(1,2))\nplot(SVF, fraction = 1, level = level)\nabline(v = 1, col = \"red\", lty = 2) # adding a line at 1 month \nplot(SVF, xlim = xlim, level = level)\nabline(v = 1, col = \"red\", lty = 2)\n\n\n\n\nWe can see that the variogram flattens (i.e., reaches an asymptote) after approximately 1 month (red line). This also indicates at how coarse the timeseries needs to be to assume independence (no autocorrelation), and corresponds to when traditional methods —such as minimum convex polygons (MCPs) and Kernel Density Estimators (KDEs)— could be applied without violating their assumptions."
  },
  {
    "objectID": "AKDE_R-tutorial.html#step-3.-selecting-the-best-fit-movement-model-through-model-selection",
    "href": "AKDE_R-tutorial.html#step-3.-selecting-the-best-fit-movement-model-through-model-selection",
    "title": "Guide to autocorrelated home range estimation",
    "section": "Step 3. – Selecting the best-fit movement model through model selection",
    "text": "Step 3. – Selecting the best-fit movement model through model selection\nIt is necessary to choose a home range estimator that accounts for the autocorrelated structure of the data, now that we see that it is not independently and identically distributed (non-IID). We need to test what movement model may explain the autocorrelated structure of our tracking data. We can run different movement processes with maximum likelihood (ML) or other parameter estimators, such as perturbative Hybrid REML (pHREML). To facilitate further comparisons, we will run both ML and pHREML with the ctmm.select function.\n\n# Calculate an automated model guesstimate:\nGUESS1 <- ctmm.guess(animal1_buffalo, interactive = FALSE)\n\n# Automated model selection, starting from GUESS:\nFIT1_ML <- ctmm.select(animal1_buffalo, GUESS1, method = 'ML')\nFIT1_pHREML <- ctmm.select(animal1_buffalo, GUESS1, method = 'pHREML')\n## reminder: it will default to pHREML if no method is specified.\n\nsummary(FIT1_ML)\nsummary(FIT1_pHREML)\n\nWithin these summaries, $name provides the selected best-fit model, $DOF provides information on the degrees of freedom (where $DOF[\"area\"] corresponds to the effective sample size of the home-range area estimate), and $CI are the parameter outputs (area, position autocorrelation timescale, velocity autocorrelation timescale, and speed).\nThe typical pool of candidate models includes isotropic (when diffusion is the same in every direction; symmetrical) and anisotropic (when diffusion varies with direction; asymmetrical) variants. The automated model selection shows that OUF anisotropic (anisotropic Ornstein-Uhlenbeck foraging process) is our best-fit model. This movement process features a home range, correlated positions, and correlated velocities. To check the full model selection table, we can run the following command:\n\nFIT1_pHREML_verbose <- ctmm.select(animal1_buffalo, GUESS1, verbose = TRUE)\nsummary(FIT1_pHREML_verbose)\n\nBy adding the argument verbose = TRUE we have access to the model selection table. By default, model selection is based on Akaike’s Information Criterion adjusted for small sample sizes (AICc). The ctmm package also offers BIC, LOOCV, and HSCV. LOOCV seems to work slightly better for very small datasets, but we recommend AICc for the majority of datasets."
  },
  {
    "objectID": "AKDE_R-tutorial.html#step-4.-feeding-a-movement-model-into-the-home-range-estimator",
    "href": "AKDE_R-tutorial.html#step-4.-feeding-a-movement-model-into-the-home-range-estimator",
    "title": "Guide to autocorrelated home range estimation",
    "section": "Step 4. – Feeding a movement model into the home range estimator",
    "text": "Step 4. – Feeding a movement model into the home range estimator\nNow we can fit this movement process into the akde() function, and estimate the home range of animal1_buffalo. This function currently defaults to the area-corrected AKDE, or AKDEc (Fleming & Calabrese 2017):\n\n# Run an area-corrected AKDE:\nUD1_ML <- akde(animal1_buffalo, FIT1_ML)\nUD1_pHREML <- akde(animal1_buffalo, FIT1_pHREML)\n\nsummary(UD1_pHREML)$CI # home range area estimation\n\nWe have calculated our home range for animal1_buffalo, resulting in an estimation of 757 km2 (with 95% confidence intervals: 430–1,175 km2)."
  },
  {
    "objectID": "AKDE_R-tutorial.html#step-5.-evaluating-additional-biases-applying-mitigation-measures",
    "href": "AKDE_R-tutorial.html#step-5.-evaluating-additional-biases-applying-mitigation-measures",
    "title": "Guide to autocorrelated home range estimation",
    "section": "Step 5. – Evaluating additional biases, applying mitigation measures",
    "text": "Step 5. – Evaluating additional biases, applying mitigation measures\n\n5.1. Buffalo tracking data\n\nsummary(UD1_pHREML)$DOF[\"area\"] # effective sample size of animal1\n\n    area \n15.65773 \n\nnrow(animal1_buffalo) # absolute sample size\n\n[1] 1725\n\n\nOur output here also reveals more information regarding our dataset: the effective sample size (N) and the absolute sample size (n). We can return this measure with the summary function: in our case, the N for animal1_buffalo is 15.7. Comparatively, our absolute sample size is easy to output, as it is the total number of observations within our dataset (n = 1,725).\n\nAbsolute sample size (n): the number of observations (fixes) in a dataset.\n\nAs mentioned earlier, animal1_buffalo had a device malfunction that led GPS fixes to shift from one fix per hour, to one fix every two hours. As such, this individual is particularly suited for a weighted AKDEc (or wAKDEc), so we can re-run the function with weights set to TRUE:\n\nUD1w_pHREML <- akde(animal1_buffalo, FIT1_pHREML, weights = TRUE)\nsummary(UD1w_pHREML)$CI # home range area estimation (weighted)\n\nOur new home range area estimation for animal1_buffalo is 761 km2 (with 95% confidence intervals: 432–1,182 km2). We can now plot our home range estimate for animal1_buffalo:\n\n# Creating an extent that includes both UDs at the 95% CI level:\nEXT <- extent(list(UD1_ML, UD1_pHREML, UD1w_pHREML), level = 0.95)\n\n# Plotting pHREML (with and without weights) side-by-side:\npar(mfrow = c(1,2))\nplot(animal1_buffalo, UD = UD1_pHREML, ext = EXT)\ntitle(expression(\"pHREML AKDE\"[\"C\"]))\nplot(animal1_buffalo, UD = UD1w_pHREML, ext = EXT)\ntitle(expression(\"pHREML wAKDE\"[\"C\"]))\n\n\n\n\nFor animal1_buffalo, the difference between model parameter estimators is not substantial; we only have a ~5.7% AKDE area underestimation by ML compared to pHREML. However, the data fits the spatial locations much better.\n\n( 1 - summary(UD1_ML)$CI[1,2] / summary(UD1w_pHREML)$CI[1,2] ) * 100\n\n[1] 5.737587\n\n\n\n\n5.2. Gazelle tracking data\nWe can also check the difference with animal2_gazelle’s tracking data, where the small effective sample size issue is clearer:\n\nGUESS2 <- ctmm.guess(animal2_gazelle, interactive = FALSE)\n\nFIT2_ML <- ctmm.select(animal2_gazelle, GUESS2, method = 'ML')\nFIT2_pHREML <- ctmm.select(animal2_gazelle, GUESS2, method = 'pHREML')\n\nUD2_ML <- akde(animal2_gazelle, FIT2_ML)\nUD2_pHREML <- akde(animal2_gazelle, FIT2_pHREML)\n\nWith animal2_gazelle, we have a more substantial area underestimation by ML compared to pHREML (~15.2%). We can also see that our effective sample size is only 4.5, with an absolute sample size of 49 (N \\ll n).\n\n( 1 - summary(UD2_ML)$CI[1,2] / summary(UD2_pHREML)$CI[1,2] ) * 100\n\n[1] 15.16696\n\nsummary(UD2_pHREML)$DOF[\"area\"] # effective sample size\n\n    area \n4.528926 \n\nnrow(animal2_gazelle) # absolute sample size\n\n[1] 49\n\n\nAt this point, we have selected a movement process, fed it into a home range area estimation with different model parameter estimators, and corrected for irregular sampling rates. With small effective sample sizes, it is important to see if parametric bootstrapping may be worth it to further reduce our estimation error. In order to do so, we can check the expected order of bias from pHREML:\n\n# Expected order of pHREML bias:\n1/summary(FIT2_pHREML)$DOF['area']^2\n\n      area \n0.04875393 \n\n\nThe bias is currently \\mathcal{O}(5\\%) (“in the order of” 5%). As such, we will run parametric bootstrapping for animal2_gazelle. The relative error target is 1% by default (argument error = 0.01), but can be adjusted if necessary.\n\nstart_time <- Sys.time() # start recording running time\nBOOT <- ctmm.boot(animal2_gazelle, FIT2_pHREML, trace = 2)\n## note: this function incurs substantial computational cost, may take hours.\n( total_time <- Sys.time() - start_time ) # output running time\n\nsummary(BOOT)\n1/summary(BOOT)$DOF['area']^3 # expected order of bias\n\nWe can see that the expected order of bias was reduced to 2.3%, which is comparable to the numerical error target of 1%. To reduce the numerical error further, we would need to change the default relative error target of ctmm.boot, but the computational cost would continue to increase, and the comparably large statistical bias (2%) would remain.\nNow we will calculate the AKDEc based on the estimated parameters, and plot the home range of animal2_gazelle. Because of small effective sample size, we set optimal weights to TRUE for improved statistical efficiency:\n\nUD2_bpHREML <- akde(animal2_gazelle, BOOT, weights = TRUE)\nsummary(UD2_bpHREML)$CI\n\nFinally, we have calculated our home range for animal2_gazelle, with an estimated area of 13,274 square kilometers (with 95% confidence intervals: 3,231–30,280 km2). Our uncertainty with animal2_gazelle is substantially higher than with animal1_buffalo, as expected due to the small effective sample size.\n\n# Creating an extent that includes both UDs at the 95% CI level:\nEXT <- extent(list(UD2_pHREML, UD2_bpHREML), level = 0.95)\n\n# Plotting pHREML and bootstrapped-pHREML side-by-side:\npar(mfrow = c(1,2))\nplot(animal2_gazelle, UD = UD2_pHREML, ext = EXT)\ntitle(expression(\"pHREML AKDE\"[\"C\"]))\nplot(animal2_gazelle, UD = UD2_bpHREML, ext = EXT)\ntitle(expression(\"Bootstrapped pHREML wAKDE\"[\"C\"]))\n\n\n\n\nThe results presented here were generated with R version 4.2.3, and ctmm version 1.1.1."
  }
]